var a=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var u=Object.prototype.hasOwnProperty;var V=(o,n)=>{for(var s in n)a(o,s,{get:n[s],enumerable:!0})},D=(o,n,s,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of h(n))!u.call(o,i)&&i!==s&&a(o,i,{get:()=>n[i],enumerable:!(r=$(n,i))||r.enumerable});return o};var k=o=>D(a({},"__esModule",{value:!0}),o);var R={};V(R,{checkMatchingRootVersionWithPeerDependencies:()=>y});module.exports=k(R);var t=require("semver"),f=require("./get-version-info-in-range"),m=require("./get-previous-version"),p=require("./get-formatted-semver-version");function y(o){const n=Object.entries(o),s=[];for(const[r,{remoteVersions:i,version:c,parentDependencies:g}]of n){if(i.length===1||!c)continue;const d=(0,t.parse)(c);if(d)for(const e of g)if((0,t.validRange)(e.needs)){if(!(0,t.satisfies)(d,e.needs)){const v=(0,f.getVersionsInfoInRange)(e.needs,i);if(console.log(`Not matched version for dependency ${r}@${c} with version ${e.needs} for package ${e.name}@${e.version}`),v.min.compare(d)!==1)s.push({name:r,needs:e.needs});else{const l=(0,m.getPreviousVersion)(e,o[e.name].remoteVersions,"minor");s.push({name:e.name,needs:(0,p.formatSemver)(l)})}}}else(0,t.valid)(e.needs)?d.compare(e.needs)!==0&&(console.log(`Not matched version for dependency ${r}@${c} with version ${e.needs} for package ${e.name}@${e.version}`),s.push({name:r,needs:e.needs})):console.log(`Unknown version for dependency ${r}: ${e.needs}`)}return s}0&&(module.exports={checkMatchingRootVersionWithPeerDependencies});
